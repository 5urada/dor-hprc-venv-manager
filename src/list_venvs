#!/usr/bin/env python3

# Created 10-31-24 by Gabriel Floreslovo 
# This script lists all of a user's virtual environments created by the create_venv script
# this is achieved by parsing the 'metadata.json' file in the user's '$SCRATCH/virtual_envs/' directory

import json
import os
import sys
import getpass
import datetime
import subprocess
import shutil
import textwrap
import shutil

def get_terminal_width():
    """Get the current terminal width, with a fallback."""
    try:
        return shutil.get_terminal_size().columns
    except:
        return 80  # fallback width

def get_groups():
    scratch_path = os.environ.get('SCRATCH')
    user = os.path.basename(scratch_path.rstrip('/'))

    groups_command = f"groups {user} > groups.txt"
    remove_command = f"rm groups.txt"
    subprocess.run(groups_command, shell=True)

    with open("groups.txt", 'r') as file:
        for line in file:
            parts = line.strip().split(':')
            if len(parts) == 2:
                uname = parts[0].strip()
                group_list = parts[1].strip().split()

                
    subprocess.run(remove_command, shell=True)
    return group_list

def get_json(group_name):
    json_path = os.path.join("/", "scratch", "group", group_name, "virtual_envs", "metadata.json")
    try:
        with open(json_path, 'r') as file:
            data = json.load(file)
        return data
    except FileNotFoundError:
        # Silently return empty dict - this is expected for groups without shared environments
        return {}
    except json.JSONDecodeError as e:
        print(f"Error: {e}")
        print(f"The metadata file for group '{group_name}' is corrupted or not in JSON format")
        return {}
    except PermissionError:
        # Silently return empty dict - user may not have access to all group directories
        return {}
    except Exception as e:
        print(f"An unexpected error occurred while reading metadata for group '{group_name}': {e}")
        return {}

def truncate_text(text, max_length):
    if len(text) <= max_length:
        return text
    return text[:max_length-3] + "..."

def wrap_text(text, width):
    if len(text) <= width:
        return [text]
    return textwrap.wrap(text, width=width, break_long_words=True, break_on_hyphens=False)

def print_json(metadata, group_name="your $SCRATCH"):
    if len(metadata.get('environments',[])) == 0:
        print(f"\nYou have no environments in {group_name} currently available through 'activate_venv'\n")
        return
    
    envs = metadata.get('environments', [])
    
    # Get terminal width and determine display format
    try:
        terminal_width = get_terminal_width()
    except:
        terminal_width = 80
    
    # Use compact format for narrow terminals
    if terminal_width < 120:
        print(f"\nThese are your virtual environments in {group_name} currently available through 'activate_venv':\n")
        for i, env in enumerate(envs, 1):
            name = env.get('name', 'N/A')
            description = env.get('description', 'N/A')
            python_ver = env.get('python_version', 'N/A')
            gcc_ver = env.get('GCCcore_version', 'N/A')
            toolchain = env.get('toolchain', 'N/A')
            owner = env.get('owner', 'N/A')
            
            print(f"{i:2d}. {name}")
            if description != 'N/A' and description.strip():
                # Wrap description if it's long
                desc_lines = wrap_text(description, terminal_width - 8)
                for line in desc_lines:
                    print(f"    {line}")
            print(f"    Python: {python_ver}  |  GCC: {gcc_ver}")
            if toolchain != 'N/A' and toolchain.strip():
                print(f"    Toolchain: {toolchain}")
            if owner != 'N/A' and owner.strip():
                print(f"    Owner: {owner}")
            if i < len(envs):
                print()
    else:
        # Use table format with text wrapping for wide terminals
        print(f"\nThese are your virtual environments in {group_name} currently available through 'activate_venv':\n")
        
        # Calculate responsive column widths
        available_width = terminal_width - 8
        base_widths = [15, 25, 15, 12, 20, 15]  # name, desc, python, gcc, toolchain, owner
        total_base = sum(base_widths)
        
        if available_width > total_base:
            # Distribute extra space
            extra = available_width - total_base
            col_widths = base_widths.copy()
            col_widths[1] += extra // 2  # Give most extra space to description
            col_widths[4] += extra - (extra // 2)  # Rest to toolchain
        else:
            # Shrink proportionally if needed
            ratio = available_width / total_base
            col_widths = [max(8, int(w * ratio)) for w in base_widths]
        
        # Headers
        headers = ["Name", "Description", "Python Version", "GCC Version", "Toolchain", "Owner"]
        
        # Print header
        header_row = ""
        for i, header in enumerate(headers):
            header_row += f"{header:<{col_widths[i]}}"
        print(header_row)
        print("-" * sum(col_widths))
        
        # Print environments with text wrapping
        for env in envs:
            row_data = [
                env.get('name', 'N/A'),
                env.get('description', 'N/A'),
                env.get('python_version', 'N/A'),
                env.get('GCCcore_version', 'N/A'),
                env.get('toolchain', 'N/A'),
                env.get('owner', 'N/A')
            ]
            
            # Wrap text for each column
            wrapped_columns = []
            max_lines = 1
            
            for i, text in enumerate(row_data):
                if text and text != 'N/A' and len(text) > col_widths[i] - 1:
                    wrapped = wrap_text(text, col_widths[i] - 1)
                    wrapped_columns.append(wrapped)
                    max_lines = max(max_lines, len(wrapped))
                else:
                    wrapped_columns.append([text])
            
            # Print each line of the wrapped text
            for line_num in range(max_lines):
                line = ""
                for col_num, wrapped_col in enumerate(wrapped_columns):
                    if line_num < len(wrapped_col):
                        text = wrapped_col[line_num]
                    else:
                        text = ""
                    line += f"{text:<{col_widths[col_num]}}"
                print(line.rstrip())

def main():
        groups = get_groups()
        for g in groups:
                print_json(get_json(g), g)
        metadataPath = os.path.expandvars("$SCRATCH/virtual_envs/metadata.json")

        # Open and load the metadata file
        try: # Try to open metadata file
                with open(metadataPath, 'r') as file:
                        metadata = json.load(file)
        except FileNotFoundError as e: # Handle different errors
                print("Error: ", e)
                print("There was no metadata file found; you likely have not yet used 'create_venv' to make a virtual environment.")
                sys.exit(1)
        except json.JSONDecodeError as e:
                print("Error: ", e)
                print("The metadata file is corrupted or not in JSON format")
                sys.exit(1)
        except Exception as e:
                print("An unexpected error occured: ",e)
                sys.exit(1)
        except: 
                print("There was an error listing your environments")

        # Show the environments the user has in their directory
        print_json(metadata)
        print(f"\nFor example, to activate 'myvenv' run this command: ")
        print(f"$ source activate_venv myvenv\n")
        # Log usage
        # Format: day username action env_name
        logfilePath = os.path.join('/sw/hprc/sw/dor-hprc-tools-dashboard-utils/logs/venv.log')

        try:
                logfile = open(logfilePath,'a')

                username = getpass.getuser()
                today = datetime.date.today()
                logString = f"{today} {username} list_venv NA\n"
                logfile.write(logString)
        except FileNotFoundError as e:
                print(f"Error: {e}")
                print("The log file was not found where it was expected to be")
                print("This action was not logged")
                sys.exit(1)
        except Exception as e:
                print(f"Error: {e}")
                print("This action was not logged")
                sys.exit(1)

if __name__ == "__main__":
    main()
